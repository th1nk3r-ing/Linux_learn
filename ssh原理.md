# <font color=#0099ff> **ssh** </font>

> `@think3r` 2019-09-19 00:13:06
> 1. [SSH 基本用法 - zhihu](https://zhuanlan.zhihu.com/p/21999778)
> 2. [Git的.ssh文件夹的内容](https://www.cnblogs.com/zxqblogrecord/p/10123083.html)
> 3. [SSH 密钥类型的的选择（RSA， DSA or Other）](http://blog.sina.com.cn/s/blog_6f31085901015agu.html)
> 4. [图解SSH原理](https://www.jianshu.com/p/33461b619d53)
> 5. [rsa公钥和私钥到底哪个才是用来加密，哪个用来解密？](https://www.cnblogs.com/007sx/p/10987906.html)
> 6. [SSH加密原理、RSA非对称加密算法学习与理解](https://www.cnblogs.com/Alenliu/p/5040062.html)

---

## <font color=#009A000> 0x00 base </font>

### <font color=#FF4500> SSH 是什么 ? </font>

SSH 是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。

- SSH 仅仅是一协议标准，其具体的实现有很多，既有开源实现的 OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现 OpenSSH。
- PS: 微软已在 windows 上对 OpenSSh 进行了支持, 项目开源在了 github. 详情, 自己搜索.
  
### <font color=#FF4500> 为什么需要 SSH？ </font>

SSH 和 telnet、ftp 等协议主要的区别在于安全性。

- ssh 和 `telnet` 等的情况不同，这其密码传输是加密的，因此它不会被偷看到我们的数据连接的人截取。

### <font color=#FF4500> 基础使用 </font>

在 Linux 系统上 SSH 是非常常用的工具，通过 SSH Client 我们可以连接到运行了 SSH Server 的远程机器上。SSH Client 的基本使用方法是: `ssh user@remote -p port`

- `user` 是你在远程机器上的用户名，如果不指定的话默认为当前用户
- `remote` 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名
- `port` 是 SSH Server 监听的端口，如果不指定的话就为默认值 `22`
  - 知道了上面这三个参数和密码，用任意的 SSH Client 都能连接上 SSH Server;
  - 在输入密码的时候，屏幕上不会显示明文密码，也不会显示 ******，这样别人就不会看到你的密码长度了，按下回车即可登入。
- 此处我们看到的是 `ssh` 处理认证的 **缺省** 方式的一个示例。
  - 换句话说，它要求我们输入 `remote` 上的 `user` 这个帐户的密码。如果我们输入我们在 `remote` 上的密码， ssh 就会用安全密码认证协议，把我们的密码传送给 `remote` 进行验证。
  - 但是，和 一旦 `remote` 把我们提供的密码同它的密码数据库相对照进行认证，成功的话，我们就会被允许登录，还会有一个 `remote` 的 shell 提示欢迎我们。

---

## <font color=#009A000> 0x01 原理 </font>

### <font color=#FF4500> 加密分类 </font>

加密的方式主要有两种：

1. **对称加密**（也称为秘钥加密）
2. **非对称加密**（也称公钥加密）

所谓 <u>对称加密</u> ，指加密解密使用同一套秘钥。

- 对称加密的加密强度高，很难破解。
- 但是在实际应用过程中不得不面临一个棘手的问题：如何安全的保存密钥呢？尤其是考虑到数量庞大的Client端，很难保证密钥不被泄露。一旦一个Client端的密钥被窃据，那么整个系统的安全性也就不复存在。
- 为了解决这个问题，非对称加密应运而生。

<u>非对称加密</u> 的核心源于数学问题, 其包含两个密钥：“公钥”和“私钥”。两个密钥的特性如下：

- 公钥与私钥是成对出现的；
- 公钥顾名思义就是公开的密钥会发放给多个持有人，而私钥是私有密码往往只有一个持有人。
- 公钥和私钥都是密钥，被公开的那个就是公钥，没有被公开的那个就是私钥。
- 密钥越长，越难破解，所以 2048 密钥比1024位密钥要更安全；
- 公钥加密后的密文，只能通过对应的私钥进行解密。
- 而通过公钥推理出私钥的可能性微乎其微。
- RSA 是一种非对称加密算法，它是由三位数学家（Rivest、Shamir、Adleman）设计出来的。

<u>公钥和私钥都可以用于加解密操作</u>，用公钥加密的数据只能由对应的私钥解密，反之亦然。虽说两者都可用于加密，但是不同场景使用不同的密钥来加密，规则如下：

1. 私钥用于签名、公钥用于验签:
   - 签名和加密作用不同，签名并不是为了保密，而是为了保证这个签名是由特定的某个人签名的，而不是被其它人伪造的签名，所以私钥的私有性就适合用在签名用途上。
   - 私钥签名后，只能由对应的公钥解密，公钥又是公开的（很多人可持有），所以这些人拿着公钥来解密，解密成功后就能判断出是持有私钥的人做的签名，验证了身份合法性。
2. **公钥用于加密、私钥用于解密，这才能起到加密作用**
   - 因为公钥是公开的，很多人可以持有公钥。若用私钥加密，那所有持有公钥的人都可以进行解密，这是不安全的！
   - 若用公钥加密，那只能由私钥解密，而私钥是私有不公开的，只能由特定的私钥持有人解密，保证的数据的安全性。

### <font color=#FF4500> ssh 原理  </font>

在 SSH 安全协议的原理中， 运用了非对称加密与对称加密算法的结合.

- 其认证过程如下图所示:
  
![原理](./image/ssh原理.webp)

**ssh 认证过程如下:**

1. `Client` 上生成一对公匙和秘匙(这对公匙和秘匙没必要非得用 `ssh-keygen`, 可以用诸如 `PenguiNet` 之类的工具生成).
2. `Client` 将自己的公钥存放在 `Server` 上，追加在文件 `authorized_keys` 中。
3. `Server` 端接收到 `Client` 的连接请求后，会在 `authorized_keys` 中匹配到 `Client` 的公钥 `pubKey`，并生成随机数 `R`，用 `Client` 的公钥对该随机数进行加密得到 `pubKey(R)`，然后将加密后信息发送给 `Client`。
4. `Client` 端通过私钥进行解密得到随机数 `R`，然后对随机数 `R` 和本次会话的 `SessionKey` 利用 `MD5` 生成摘要 `Digest1` ，发送给 `Server` 端。
5. `Server` 端会也会对 `R` 和 `SessionKey` 利用同样摘要算法生成 `Digest2`。
6. `Server` 端会最后比较 `Digest1` 和 `Digest2` 是否相同，完成认证过程。
   - 需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。

---

每次 ssh 都要输入密码是不是很烦呢？与密码验证相对的，是公钥验证。也就是说，要实现免密码登入. 首先要设置 SSH 钥匙。我们只需要执行这些初始配置步骤一次, 之后的再次认证登陆就毫不费力了。

- `ssh-keygen -t rsa -C "yourname@email.com" -f ~/.ssh/id_rsa`
  - `-f`：指定存放密钥的文件（公钥文件默认和私钥同目录下，不同的是，存放公钥的文件名需要加上后缀.pub）
  - `-t` 用来指定密钥类型, 密钥有两种类型 `rsa` 和 `dsa` 两种:
    - RSA 与 DSA 都是非对称加密算法。其中 RSA 的安全性是基于极其困难的大整数的分解（两个素数的乘积）；DSA 的安全性是基于整数有限域离散对数难题。基本上可以认为相同密钥长度的 RSA 算法与 DSA 算法安全性相当。
    - DSA 只能用于数字签名，而无法用于加密（某些扩展可以支持加密）；RSA 即可作为数字签名，也可以作为加密算法。不过作为加密使用的 RSA 有着随密钥长度增加，性能急剧下降的问题。

接下来，我们要让远程机器记住我们的公钥:

- `ssh-copy-id user@remote -p port`
- `ssh user@remote -p port 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub`
  - 在远端执行新建 `.ssh` 文件夹，并把本地的 `~/.ssh/id_rsa.pub` （也就是公钥）追加到远端的 `.ssh/authorized_keys` 中。

---

**注意:** <u>要正确理解公匙模式下的认证过程! 首先我们需要了解如下的一些基础知识: </u>

- 当从 `ssh-Client` 连接 `ssh-Server` 的时候，需要在 `ssh-Client` 上保存一对公匙和秘匙 (这对公匙和秘匙没必要非得用 `ssh-keygen`, 可以用诸如 `PenguiNet` 之类的工具生成) ，而只要把生成的公匙传到 Server 上即可。
  - 在 Server 上，公匙往往被是被放在 `~/.ssh/authorized_keys` 这个文件中。这个文件的设置可以在 `/etc/ssh/sshd_config` 中找到。
- 公用密钥用于对消息进行加密，只有拥有专用密钥的人才能对该消息进行解密。公用密钥只能用于 加密，而专用密钥(私钥)只能用于对由匹配的公用密钥编码的消息进行 解密。
- RSA（和 DSA）认证协议利用密钥对的这些特殊性质进行安全认证，并且不需要在网上传输任何保密的信息。
  - 公用密钥之所以被称作是 “公用的” 有一个原因。因为它只能用于对那些给我们的消息进行加密，所以我们不需要太担心它会落入其它人手中。
- 一旦我们的公用密钥已经被拷贝到 remotebox 并且为了 remotebox 的 sshd 能够定位它而把它放在一个专门的文件（`~/.ssh/authorized_keys`）里，我们就为使用 RSA 认证登录到 remotebox 上做好了准备。

使用密钥登录的时候:

1. 我们只要在 localbox 的控制台键入 `ssh drobbins@remotebox` ，就象我们常做的一样。
   - 可这一次， ssh 告诉 remotebox 的 sshd 它想使用 RSA 认证协议。
2. 接下来发生的事情非常有趣。 Remotebox 的 sshd 会生成一个随机数，并用我们先前拷贝过去的公用密钥对这个随机数进行加密。然后， sshd 把加密了的随机数发回给正在 localbox 上运行的 ssh 。
3. 接下来，轮到我们的 ssh 用专用密钥对这个随机数进行解密后，再把它发回给 remotebox，
   - 实际上等于在说：“瞧，我 确实有匹配的专用密钥；我能成功的对您的消息进行解密！”
4. 最后， sshd 得出结论，既然我们持有匹配的专用密钥，就应当允许我们登录。因此，我们有匹配的专用密钥这一事实授权我们访问 remotebox。

## <font color=#009A000> 0x02 别名 </font>

每次都输入 `ssh user@remote -p port`，时间久了也会觉得很麻烦，特别是当 `user`, `remote` 和 `port` 都得输入，而且还不好记忆的时候。配置别名可以让我们进一步偷懒。在 `~/.ssh/config` 里面追加以下内容：

```sh
Host alias
    HostName remote
    User user
    Port port
Host mi6
    HostName 192.168.1.11
    User my_Mi6_userName
    Port 8022    
```

- 使用: `ssh alias` 即可;
